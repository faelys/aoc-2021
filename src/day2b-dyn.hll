/*
 * Copyright (c) 2021, Natacha Port√©
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This is a dynamic rewrite of day2b.hll.
 * The input data sequence is represented as the successive values of
 * `dir` and `amount`, with an internal state being updated at each time
 * frame.
 * To make a stop condition, an extra direction value is added, with the PO
 * that this stop value is never reached, so that a counter-example for this
 * PO is a finite sequence of commands.
 * The output is now a stream of values, and the answer is the value when
 * the PO is falsified.
 * Note that sanity cannot be proved without bounding the time or adding
 * complicated constraints to the inputs, so it's ignored here.
 *
 * We don't have a tool to feed user-defined input values and "run" the HLL,
 * so instead we have to expand it into LLL and somehow generate a LLL model,
 * which can then be run and mapped back to HLL entities.
 *
 * This should first be expanded, using:
 *   expand1 -hll day2b-dyn.hll -lll day2b-dyn.lll \
 *           -dumpMap day2b-dyn.map -noSanityAnalysis
 *
 * An XML counter-example can be generated by s3-CORE if the constraints
 * below are uncommented:
 *   s3 -lll day2b-dyn.lll -cex day2b-dyn.cex -analyse 2 -bmc
 * OR generated from AoC data using the companion script:
 *   ./day2-input.sh $(wc -l day2-input.txt) <day2-input.txt >day2b-dyn.cex
 *
 * The answer can then be found by exploring the counter-example with:
 *   cex_simulator -hll day2b-dyn.hll -map day2b-dyn.map \
 *                 -cex dyn2b-dyn.cex -res day2b-dyn.res -O
 * OR:
 *   why -hll day2b-dyn.hll -map day2b-dyn.map -cex dyn2b-dyn.cex
 *   $out 1
 *
 * The I/O is a bit contrived, but the core logic is much simpler. Admittedly
 * this puzzle is so simple that there is no need to make the logic simpler,
 * but that may change as the puzzles get more difficult.
 */

Types:
  enum { finished, forward, up, down } direction;

Inputs:
  direction dir;
  int unsigned 4 amount;

Declarations:
  int unsigned 16 position;
  int unsigned 24 depth;
  int unsigned 16 aim;

Definitions:
  aim := 0, aim + (dir
                  | finished => 0
                  | forward  => 0
                  | up       => -amount
                  | down     => amount);

  position := 0, position + (if dir = forward then amount else 0);

  depth := 0, depth + (if dir = forward then amount * aim else 0);

Outputs:
  position * depth;

Constraints:
/*
 * Without a counter-example in which the input sequence is encoded,
 * the following constraints can force de input variables to hold a
 * given sequence:
 *
  I(dir = forward);
  I(X(dir = down));
  I(X(X(dir = forward)));
  I(X(X(X(dir = up))));
  I(X(X(X(X(dir = down)))));
  I(X(X(X(X(X(dir = forward))))));
  I(X(X(X(X(X(X(dir = finished)))))));

  I(amount = 5);
  I(X(amount = 5));
  I(X(X(amount = 8)));
  I(X(X(X(amount = 3))));
  I(X(X(X(X(amount = 8)))));
  I(X(X(X(X(X(amount = 2))))));
  I(X(X(X(X(X(X(amount = 0)))))));
 */
Proof Obligations:
  dir != finished;
