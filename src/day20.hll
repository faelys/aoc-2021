/*
 * Copyright (c) 2021, Natacha Port√©
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This is another image-processing puzzle, and I encountered the same
 * memory limitation as in day 15. But then I tried expressing the
 * processing steps spatially instead of temporally, and it turned out to fit.
 * Maybe I'll try revisiting day 15 with this idea.
 *
 * The 2D infinity is managed by having the borders stand out of infinity,
 * with the $min and $max in tr() call duplicating these cells beyond the
 * existing area, and the PO checks that they are correct representation of
 * whatever is beyond (i.e. that the borders are far enough from the middle
 * not to be affected).
 *
 * This is used directly in the why tool:
 * $ why -hll day20.hll
 *   answer_1
 *   answer_2
 */

Constants:
  int steps := 50;
  int xinit := 5;
  int yinit := 5;
  int border := 2 + steps;
  int xmax := xinit + 2 * border;
  int ymax := yinit + 2 * border;

Declarations:
  int transform[512];
  int input_image[yinit, xinit];
  int[0,1] image[xmax+1, ymax+1, steps+1];
  int tr(int, int, int, int, int, int, int, int, int);

Definitions:
  tr(a, b, c, d, e, f, g, h, i) :=
    transform[$or($or($or($or(a << 8, b << 7), $or(c << 6, d << 5)),
                      $or($or(e << 4, f << 3), $or(g << 2, h << 1))),
                  i)];

  image[x, y, t] := if t = 0
                    then (if (x-border):[0, xinit-1] & (y-border):[0, yinit-1]
                          then input_image[y-border, x-border] else 0)
                    else tr(image[$max(x-1, 0),    $max(y-1, 0),    t-1],
                            image[     x,          $max(y-1, 0),    t-1],
                            image[$min(x+1, xmax), $max(y-1, 0),    t-1],
                            image[$max(x-1, 0),         y,          t-1],
                            image[     x,               y,          t-1],
                            image[$min(x+1, xmax),      y,          t-1],
                            image[$max(x-1, 0),    $min(y+1, ymax), t-1],
                            image[     x,          $min(y+1, ymax), t-1],
                            image[$min(x+1, xmax), $min(y+1, ymax), t-1]);

  answer_1 := if image[0,0, 2] = 1 then -1
              else SUM x:[0, xmax], y:[0, ymax] (image[x, y, 2]);
  answer_2 := if image[0,0, 50] = 1 then -1
              else SUM x:[0, xmax], y:[0, ymax] (image[x, y, 50]);

Outputs:
  answer_1;
  answer_2;

Proof Obligations:
  ALL t:[0, steps], x:[0, xmax]
    (image[x, 0, t] = image[0, 0, t]
     & image[x, 1, t] = image[0, 0, t]
     & image[x, ymax-1, t] = image[0, 0, t]
     & image[x, ymax, t] = image[0, 0, t])
  &
  ALL t:[0, steps], y:[0, ymax]
    (image[0, y, t] = image[0, 0, t]
     & image[1, y, t] = image[0, 0, t]
     & image[xmax-1, ymax, t] = image[0, 0, t]
     & image[xmax, ymax, t] = image[0, 0, t]);

Definitions:
  /* generated by filtering AoC input to `sed -f day20-input.sed` */
  transform := {
    0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1,
    0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0,
    1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1,
    0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1,
    1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0,
    1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1,
    1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0,
    0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1,
    1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,
    0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1,
    1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1,
    0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0,
    1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0,
    0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
    0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0,
    1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
    0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
    1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1,
    0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1,
    1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1
  };

  input_image := {
    { 1, 0, 0, 1, 0 },
    { 1, 0, 0, 0, 0 },
    { 1, 1, 0, 0, 1 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 1, 1 }
  };
