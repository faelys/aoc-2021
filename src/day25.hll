/*
 * Copyright (c) 2021, Natacha PortÃ©
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This is another huge automaton, so I re-used the idea of iterating
 * through the cex_simulator, each step feeding the output of the preivous
 * step using an external loop, until the end condition is met.
 */

Constants:
  int T := 10;
  int v := 1;
  int h := 2;

Declarations:
  int grid[T+1][W, H];
  int h_count[T+1];
  int v_count[T+1];
  bool finished[T+1];
  int last_state[W*H];

Definitions:
  grid[t][x, y]
    := if t = 0 then init_grid[y*W+x]
       elif t % 2 = 1
       then (if grid[t-1][x, y] = 0 & grid[t-1][(x+W-1)%W, y] = h then h
             elif grid[t-1][x, y] = h & grid[t-1][(x+1)%W, y] = 0 then 0
             else grid[t-1][x, y])
       else (if grid[t-1][x, y] = 0 & grid[t-1][x, (y+H-1)%H] = v then v
             elif grid[t-1][x, y] = v & grid[t-1][x, (y+1)%H] = 0 then 0
             else grid[t-1][x, y]);

  h_count[t] := SUM x:[0,W-1], y:[0, H-1] (if grid[t][x, y] = h then 1 else 0);
  v_count[t] := SUM x:[0,W-1], y:[0, H-1] (if grid[t][x, y] = v then 1 else 0);
  finished[t] := t >= 2 & (t % 2 = 0) & grid[t-2] = grid[t];
  answer_1 := if finished[T - T%2]
              then (T0 + $min t:[0,T] (if finished[t] then t else T+1)) / 2
              else -1;
  last_state[i] := grid[T][i%W, i/W];

Outputs:
  answer_1;
  T0 + T;
  last_state;

Proof Obligations:
  ALL t:[1,T] (h_count[t] = h_count[0] & v_count[t] = v_count[0]);
  answer_1 > 0;

Constants:
  int T0 := 0;
  int W := 10;
  int H := 9;
Declarations:
  int init_grid[H*W];
Definitions:
  init_grid := {
    /*
     * Generated by filtering AoC input through
     * sed 's/\./0/g;s/>/h/g;s/./&, /g;s/^/    /;s/, $/,/;$s/,$//'
     */
    v, 0, 0, 0, h, h, 0, v, v, h,
    0, v, v, h, h, 0, v, v, 0, 0,
    h, h, 0, h, v, h, 0, 0, 0, v,
    h, h, v, h, h, 0, h, 0, v, 0,
    v, h, v, 0, v, v, 0, v, 0, 0,
    h, 0, h, h, 0, 0, v, 0, 0, 0,
    0, v, v, 0, 0, h, 0, h, v, 0,
    v, 0, v, 0, 0, h, h, v, 0, v,
    0, 0, 0, 0, v, 0, 0, v, 0, h
 };
