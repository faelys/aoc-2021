/*
 * Copyright (c) 2021, Natacha PortÃ©
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Today the puzzle is a bingo game, which has an intuitive time element.
 * It would probably be more satisfying to have drawn_number as an input,
 * so the sanity could easily be provable, but it seems easier to just
 * hardcode all input data, grids and drawn numbers alike, making the time
 * counter eventually overflow.
 *
 * There are 2 proof obligations, whose negations give the final time of
 * each puzzle, so that it can be computed non-interactively with s3 core:
 *   expand1 -hll day4.hll -lll day4.lll -dumpMap day4.map
 *   s3 -lll day4.lll -cex day4.cex -analyse 1 2 join in 1 group -bmc
 *   cex_simulator -hll day4.hll -map day4.map -cex day4.cex -res day4.res -O
 * for the first puzzle, and the same for the second puzzle except
 * with `1 3` instead of `1 2` on the s3 invocation.
 *
 * However s3 is quite slow (64s on my computer), probably because of the
 * full expansions against the grid list. It is much faster to use the why
 * tool directly on the HLL (i.e. `why -hll day4.hll`), draw all the numbers
 * using `$depth 27` or `$depth 100` (the same value as T), and find the time
 * manually by looking for the first value which is not -1 in `$out 1` and
 * `$out 2` (for the first and second puzzle, respectively).
 */

Constants:
  int W := 5; /* grid width */
  int H := 5; /* grid height */

  /* Values for reference input */
  int N := 3; /* number of grids */
  int T := 27; /* number of drawn numbers */

  /* Values for user-specific inputs
  int N := 100; /* number of grids */
  int T := 100; /* number of drawn numbers */
  */

Declarations:
  int [0,T] t;
  int draw[T];
  int grids[N][W, H];

  int drawn_number;
  bool marked[N][W, H];
  bool full_row[N, H];
  bool full_col[N, W];
  bool winning_grid[N];
  int win_count;
  int unmarked_sum[N];
  int answer1;

  int [-1,N] last_win_grid;
  int answer2;

Definitions:
  t := 0, t + 1;

  /* Puzzle inputs */
  /* generated by filtering AoC input to `sed -f day4-input.sed` */
  draw := {
    7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1
  };
  grids := {
    {
      { 22, 13, 17, 11,  0 },
      {  8,  2, 23,  4, 24 },
      { 21,  9, 14, 16,  7 },
      {  6, 10,  3, 18,  5 },
      {  1, 12, 20, 15, 19 }
    }, {
      {  3, 15,  0,  2, 22 },
      {  9, 18, 13, 17,  5 },
      { 19,  8,  7, 25, 23 },
      { 20, 11, 10, 24,  4 },
      { 14, 21, 16, 12,  6 }
    }, {
      { 14, 21, 17, 24,  4 },
      { 10, 16, 15,  9, 19 },
      { 18,  8, 23, 26, 20 },
      { 22, 11, 13,  6,  5 },
      {  2,  0, 12,  3,  7 }
    }
  };

  /* First puzzle */

  drawn_number := draw[t];
  marked[n][x, y] := false, marked[n][x, y] # grids[n][x, y] = drawn_number;
  full_row[n, y] := ALL x:[0,W-1] (marked[n][x, y]);
  full_col[n, x] := ALL y:[0,H-1] (marked[n][x, y]);
  winning_grid[n] := SOME x:[0,W-1] (full_col[n, x])
                   # SOME y:[0,H-1] (full_row[n, y]);
  win_count := SUM n:[0,N-1] (if winning_grid[n] then 1 else 0);
  unmarked_sum[n] := SUM x:[0,W-1], y:[0,H-1]
                     (if marked[n][x, y] then 0 else grids[n][x, y]);
  answer1 := (if win_count != 1 then -1 else
              draw[t-1] * unmarked_sum[SELECT n:[0,N-1] (winning_grid[n])]);

  /* Second puzzle */

  last_win_grid := -1, if last_win_grid > 0 then last_win_grid
                       else if win_count < N-1 then -1
                            else SELECT n:[0,N-1] (~winning_grid[n]);
  answer2 := (if win_count != N then -1 else
              draw[t-1] * unmarked_sum[last_win_grid]);

Outputs:
  answer1;
  answer2;

Proof Obligations:
  ~SOME n:[0,N-1] (winning_grid[n]);
  ~ALL n:[0,N-1] (winning_grid[n]);
